<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://mattconn.github.io/favicon.ico><link rel=stylesheet href=https://mattconn.github.io/css/style.min.css><link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css><script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js></script>
<script>hljs.initHighlightingOnLoad()</script><script type=text/x-mathjax-config>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ["\\(", "\\)"]],
      processEscapes: true,
    }
  }
</script><title>Comparing Array-Based Stacks in C and Go</title><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><header id=banner><h2><a href=https://mattconn.github.io>MattConn</a></h2><nav><ul><li><a href=https://mattconn.github.io/ title>Home</a></li><li><a href=https://mattconn.github.io/projects title>Projects</a></li><li><a href=https://github.com/mattConn title>GitHub</a></li><li><a href=https://docs.google.com/document/d/1xpLTFJak9plpU-bo0I6GRmdDIijkfauvG1_zgg2dopc/edit title>Resume</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Comparing Array-Based Stacks in C and Go</h1><time>July 5, 2020</time></header><p><img src=https://mattconn.github.io/images/gopher.png alt></p><p>I&rsquo;ll be comparing stack-based arrays in C and Go. There are many ways to implement a stack, but the aim here is for simplicity.</p><h1 id=stacks-in-c>Stacks in C</h1><hr><h2 id=non-functionial-approach>Non-Functionial Approach</h2><p>Filling a stack with integers 1 through 10.</p><pre tabindex=0><code>#include &lt;stdio.h&gt;

int main()
{
        int stack[10];
        int top = -1; 

        int i = 1;
        while(top+1 &lt; 10) 
        {   
                stack[++top] = i;
                i++;
        }   

	// print 
        for(int i=0; i &lt; 10; i++) printf(&#34;STACK[%d]=%d\n&#34;,i,stack[i]); 


        return 0;
}
</code></pre><p>In need of a stack, this will do. The big deal here is <code>stack[++top]=i</code> which is our push functionality. Pop can be achieved similarly, and peek is <code>stack[top]</code>.</p><h2 id=functional-approach>Functional Approach</h2><p>Things get more interesting with functions involved. The code is more resuable, unlike the code above which is more of a one-off.</p><pre tabindex=0><code>#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;

bool push(int arr[], int size, int *top, int element);

int main(){
        int stack[10];
        int top = -1; 

        int i = 0;
        while(push(stack, 10, &amp;top, ++i)){}

	// print 
        for(int i=0; i &lt; 10; i++) printf(&#34;STACK[%d]=%d\n&#34;,i,stack[i]); 

        return 0;
}

bool push(int arr[], int size, int *top, int element)
{
        if((*top)+1 == size) return false;
        arr[++(*top)] = element;

        return true;
}
</code></pre><p>Now the function will all the work in a while loop like <code>while(push(stack, 10, &top, ++i)){}</code>.</p><h1 id=stacks-in-go>Stacks in Go</h1><hr><h2 id=without-functions>Without Functions</h2><p>Nearly identical to C:</p><pre tabindex=0><code>package main

import &#34;fmt&#34;

func main(){
        var stack [10]int                         
        top := -1 

        i := 1
        for top+1 &lt; 10 {
                top++
                stack[top] = i
                i++
        }                     

	// print
        for i := range stack {fmt.Printf(&#34;STACK[%d]=%d\n&#34;,i,stack[i])}
}
</code></pre><p>There are some syntax differences such as Go&rsquo;s lack of a prefix increment operator which would make a terse statement like <code>stack[++top] = i;</code> possible in C.</p><p>It&rsquo;s also worth noting that the array declared as <code>var stack [10]int</code> is automatically zeroed-out.</p><h2 id=with-functions>With Functions</h2><pre tabindex=0><code>package main

import &#34;fmt&#34;

func push(arr []int, top *int, element int) bool {
        if *top + 1 == len(arr) {return false}
        *top++
        arr[*top] = element

        return true
}

func main(){
        var stack [10]int
        top := -1

        i := 1
        for push(stack[:],&amp;top,i) != false {i++}

        // print
        for i := range stack {fmt.Printf(&#34;STACK[%d]=%d\n&#34;,i,stack[i])}

}
</code></pre><p>We can put what is essentially a while loop to work again but this time, in Go syntax as <code>for push(stack[:],&top,i) != false {i++}</code>. We cannot increment our <code>i</code> variable here in our function call like we can in C unfortunately, so the body of our loop gets a single line.</p><p>There is a greater difference here, however. When passing the array to the <code>push</code> function, it must be passed as a slice (a dynamic subarray pointing to the actual array). The expression <code>stack[:]</code> creates this slice with the endpoints omitted.</p><p>To not pass in a slice, the function signature would look like <code>func push(arr [10]int, top *int, element int) bool</code>, where the size of the array must be explicitly stated and therefore only size 10 arrays would be allowed in this function.</p><h1 id=gos-built-in-dynamic-arrays>Go&rsquo;s Built-In Dynamic Arrays</h1><p>Go will let you append to a slice with a statement like <code>stack = append(stack, i)</code>, which would manage the top of the stack for you, the catch being that this can only be done with slices and not statically sized arrays.</p></article></main><footer id=footer></footer></body></html>